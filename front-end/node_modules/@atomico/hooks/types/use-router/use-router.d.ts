/**
 * @template T
 * allows you to listen to only one route
 * @param {import("./src/matches").Routes} routes
 * @returns {[T, StringPath, ParamsPath, SearchPath]}
 */
export function useRouter<T>(routes: import("./src/matches").Routes): [T, string, {
    [x: string]: string;
}, {
    [x: string]: string;
}];
/**
 * @template T
 * allows you to listen to only one route
 * @param {string} path
 * @param {import("./src/matches").RouterCallback} [callback]
 * @returns {[T, StringPath, ParamsPath, SearchPath]}
 */
export function useRoute<T>(path: string, callback?: import("./src/matches.js").RouterCallback | undefined): [T, string, {
    [x: string]: string;
}, {
    [x: string]: string;
}];
/**
 * Create a match function to manually compare route matches,
 * the instance of this hook listens for route changes
 * @example
 * ```js
 * const match = useRouteMatch();
 *
 * if(match("/")){
 *  console.log("in root")
 * }
 *
 * console.log(match("/:id"))
 * ```
 * @returns {(path:string)=>import("@uppercod/exp-route").Match}
 */
export function useRouteMatch(): (path: string) => import("@uppercod/exp-route").Match;
/**
 * Capture the click events of a reference to find
 * if a node declares href to associate redirection
 * @param {import("atomico").Ref<Element>} ref
 * @param {(path:string)=>string} [proxy] allows to change the redirect url
 */
export function useRedirect(ref: import("atomico").Ref<Element>, proxy?: ((path: string) => string) | undefined): void;
export type InternalState = {
    path?: string | undefined;
    result?: any;
};
export type StringPath = string;
export type ParamsPath = {
    [x: string]: string;
};
export type SearchPath = {
    [x: string]: string;
};
export { redirect, getPath } from "./src/history.js";
