'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const HASH = "(?:(?:/){0,1}#(?:/){0,1})";
const SLASH = "(?:/)";
/**
 *
 * @param {string} path
 * @return {[RegExp,string[]]}
 */
function pathToRegExp(path) {
    const params = [];
    const regFolders = path
        .replace(/#(\/){0,1}/, "/#")
        .split(/\//g)
        .map((folder) => {
            if (!folder) return "";
            const [, hash = "", type, spread, param] = folder.match(
                /(#){0,1}([\{\[]){0,1}(\.\.\.){0,1}(\w*)([\}\]]){0,1}/
            );
            if (type == "{" || type == "[") {
                params.push(param);
                const wildcard = type == "[" ? "*" : "+";
                const slash =
                    (hash ? HASH : SLASH) + (type == "[" ? "{0,1}" : "{1}");
                return spread
                    ? `${slash}(.${wildcard})`
                    : `${slash}([^\/#]${wildcard})`;
            } else {
                return (
                    (hash ? HASH : "/") +
                    ignore(hash ? folder.slice(1) : folder)
                );
            }
        })
        .join("");
    // Hash paths escape the path start requirement
    const isHash = !regFolders.indexOf(HASH);
    return [
        RegExp(
            (isHash ? "" : "^") +
                (regFolders || SLASH + "{0,1}") +
                // closed paths are only enabled out of hash
                (!isHash && path != "/" && path.endsWith("/") ? "/" : "") +
                "$"
        ),
        params,
    ];
}

/**
 *
 * @param {string} str
 */
const ignore = (str) => str.replace(/([.+^()\-:])/g, "\\$1");

/**
 *
 * @param {string} path
 */
const getParts = (path) => path.split(/(\?.*)/);
/**
 * @param {string} search
 * @param {Object} [props]
 */
function searchParams(search, props = {}) {
    search.replace(
        /(?:\?|&){1}([^=&]+)(?:=([^\?&]+)){0,1}/g,
        /**
         * @param {string} _
         * @param {string} index
         * @param {string} value
         */
        (_, index, value) => {
            props[index] = value;
            return "";
        }
    );
    return props;
}

/**
 *
 * @param {string} regPath
 */
function createMatch(regPath) {
    const [path] = getParts(regPath);
    const [testPath, paramsPath] = pathToRegExp(path);
    /**
     * @param {string} request
     */
    const match = (request) => {
        const [path] = getParts(request);
        const test = path.match(testPath);
        if (test) {
            const [, ...args] = test;
            const query = {};
            return args.reduce((p, value, index) => {
                p[paramsPath[index]] = value;
                return p;
            }, query);
        }
    };
    return match;
}

exports.createMatch = createMatch;
exports.getParts = getParts;
exports.searchParams = searchParams;
